#include <Arduino.h>

// Motor GPIO Definitions
#define M1_A 5
#define M1_B 18
#define M1_C 19
#define M2_A 16
#define M2_B 4
#define M2_C 0
#define M3_A 32
#define M3_B 12
#define M3_C 13
#define M4_A 25
#define M4_B 26
#define M4_C 27
#define M5_A 15
#define M5_B 23
#define M5_C 21

// Lock pins for motors 1-4
#define M1_LOCK 17
#define M2_LOCK 2
#define M3_LOCK 33
#define M4_LOCK 14

// Mutex for task synchronization
SemaphoreHandle_t motorMutex;

// Motor structure
struct Motor {
  const char* name;
  int pin1, pin2, pin3;
  int lockPin;           // Pin for motor lock, -1 if no lock
  volatile int dir;      // 0 = CCW, 1 = CW
  volatile int vel;      // delay in ms
  volatile bool run;     // true = active
  volatile bool locked;  // true = locked
  TaskHandle_t taskHandle;
};

// Motor configurations
Motor motors[5] = {
  {"M1", M1_A, M1_B, M1_C, M1_LOCK, 1, 12, false, false, NULL},
  {"M2", M2_A, M2_B, M2_C, M2_LOCK, 1, 12, false, false, NULL},
  {"M3", M3_A, M3_B, M3_C, M3_LOCK, 1, 12, false, false, NULL},
  {"M4", M4_A, M4_B, M4_C, M4_LOCK, 1, 12, false, false, NULL},
  {"M5", M5_A, M5_B, M5_C, -1, 1, 12, false, false, NULL}  // No lock for M5
};

// Turn off all motor pins (set to 0V)
void disableMotor(Motor* m) {
  digitalWrite(m->pin1, LOW);
  digitalWrite(m->pin2, LOW);
  digitalWrite(m->pin3, LOW);
}

// Step motor based on direction
void stepMotor(Motor* m) {
  int d = m->vel;
  
  if (m->dir == 0) {  // CCW
    digitalWrite(m->pin1, LOW); delay(d);
    digitalWrite(m->pin2, HIGH); delay(d);
    digitalWrite(m->pin3, LOW); delay(d);
    digitalWrite(m->pin1, HIGH); delay(d);
    digitalWrite(m->pin2, LOW); delay(d);
    digitalWrite(m->pin3, HIGH); delay(d);
  } else {            // CW
    digitalWrite(m->pin1, LOW); delay(d);
    digitalWrite(m->pin3, HIGH); delay(d);
    digitalWrite(m->pin2, LOW); delay(d);
    digitalWrite(m->pin1, HIGH); delay(d);
    digitalWrite(m->pin3, LOW); delay(d);
    digitalWrite(m->pin2, HIGH); delay(d);
  }
}

// Motor control task
void motorTask(void* param) {
  Motor* m = (Motor*)param;
  
  while (1) {
    // Take the mutex for thread safety
    xSemaphoreTake(motorMutex, portMAX_DELAY);
    
    bool shouldRun = m->run && !m->locked;
    
    // Release mutex
    xSemaphoreGive(motorMutex);
    
    if (shouldRun) {
      stepMotor(m);
    } else {
      disableMotor(m); // Turn off all pins when motor is not running
      delay(50);
    }
  }
}

// Command processing
void processCommand(String cmd) {
  xSemaphoreTake(motorMutex, portMAX_DELAY);
  
  if (cmd == "ALLON") {
    for (int i = 0; i < 5; i++) motors[i].run = true;
  } 
  else if (cmd == "ALLOFF") {
    for (int i = 0; i < 5; i++) motors[i].run = false;
  } 
  else {
    for (int i = 0; i < 5; i++) {
      String prefix = "M" + String(i + 1);
      
      if (cmd == prefix + "0") {
        motors[i].dir = 1; motors[i].run = true;
      } 
      else if (cmd == prefix + "1") {
        motors[i].dir = 0; motors[i].run = true;
      } 
      else if (cmd == prefix + "OFF") {
        motors[i].run = false;
      } 
      else if (cmd.startsWith(prefix + "S")) {
        // Shortened speed command: M1S20 instead of M1SPD=20
        int spd = cmd.substring((prefix + "S").length()).toInt();
        motors[i].vel = constrain(spd, 1, 100);  // limit to safe range
      }
      else if (motors[i].lockPin != -1) {
        if (cmd == prefix + "L") {  // Lock motor
          motors[i].locked = true;
          digitalWrite(motors[i].lockPin, HIGH);
        } 
        else if (cmd == prefix + "U") {  // Unlock motor
          motors[i].locked = false;
          digitalWrite(motors[i].lockPin, LOW);
        }
      }
    }
  }
  
  xSemaphoreGive(motorMutex);
  Serial.println("OK: " + cmd);
}

// Serial command processor task
void serialTask(void* parameter) {
  while (1) {
    if (Serial.available()) {
      String cmd = Serial.readStringUntil('\n');
      cmd.trim();
      processCommand(cmd);
    }
    delay(20);
  }
}

void setup() {
  Serial.begin(115200);
  
  // Create mutex for thread safety
  motorMutex = xSemaphoreCreateMutex();
  
  // Setup GPIOs
  for (int i = 0; i < 5; i++) {
    pinMode(motors[i].pin1, OUTPUT);
    pinMode(motors[i].pin2, OUTPUT);
    pinMode(motors[i].pin3, OUTPUT);
    
    // Setup lock pins
    if (motors[i].lockPin != -1) {
      pinMode(motors[i].lockPin, OUTPUT);
      digitalWrite(motors[i].lockPin, LOW); // Unlocked by default
    }
    
    // Set all pins to LOW initially
    disableMotor(&motors[i]);
  }
  
  // Launch motor tasks distributed across cores
  for (int i = 0; i < 5; i++) {
    // Balance load: M1,M3,M5 on core 0, M2,M4 on core 1
    int core = (i % 2 == 0) ? 0 : 1;
    xTaskCreatePinnedToCore(
      motorTask,
      motors[i].name,
      2048,
      &motors[i],
      1,
      &motors[i].taskHandle,
      core
    );
  }
  
  // Create serial task on core 1
  xTaskCreatePinnedToCore(
    serialTask,
    "SerialTask",
    2048,
    NULL,
    2,  // Higher priority
    NULL,
    1
  );
  
  Serial.println("READY. Commands:");
  Serial.println("M10/M11/M1OFF - Motor 1 CW/CCW/Stop");
  Serial.println("M1S20 - Set Motor 1 speed to 20ms");
  Serial.println("M1L/M1U - Lock/Unlock Motor 1");
  Serial.println("ALLON/ALLOFF - All motors on/off");
}

void loop() {
  // Main loop empty as tasks handle everything
  delay(1000);
}
