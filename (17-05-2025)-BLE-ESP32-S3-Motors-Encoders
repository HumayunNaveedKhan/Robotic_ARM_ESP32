#include <Arduino.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <freertos/semphr.h>
#include <ArduinoBLE.h>

// BLE UART Service UUIDs
#define SERVICE_UUID        "6E400001-B5A3-F393-E0A9-E50E24DCCA9E" // Nordic UART Service
#define CHAR_UUID_RX        "6E400002-B5A3-F393-E0A9-E50E24DCCA9E" // Write
#define CHAR_UUID_TX        "6E400003-B5A3-F393-E0A9-E50E24DCCA9E" // Notify

// Create BLE service and characteristics
BLEService uartService(SERVICE_UUID);
BLEStringCharacteristic rxCharacteristic(CHAR_UUID_RX, BLEWrite | BLEWriteWithoutResponse, 50);
BLEStringCharacteristic txCharacteristic(CHAR_UUID_TX, BLERead | BLENotify, 100);

// IR2130 Gate Driver pins
#define HIN1 4
#define HIN2 5
#define HIN3 9
#define LIN1 10
#define LIN2 15
#define LIN3 16

// Relay pins for motor control (Active LOW)
#define RELAY1 17
#define RELAY2 18
#define RELAY3 8
#define RELAY4 11
#define RELAY5 12

// Claw motor control pins (L298N)
#define CLAW_IN1 13
#define CLAW_IN2 14

// Encoder pins
#define ENC1_A 19
#define ENC1_B 20
#define ENC2_A 21
#define ENC2_B 35
#define ENC3_A 36
#define ENC3_B 37
#define ENC4_A 38
#define ENC4_B 39
#define ENC5_A 1
#define ENC5_B 2

// Arrays for easy access to pins
const int RELAY_PINS[5] = {RELAY1, RELAY2, RELAY3, RELAY4, RELAY5};
const int ENC_A_PINS[5] = {ENC1_A, ENC2_A, ENC3_A, ENC4_A, ENC5_A};
const int ENC_B_PINS[5] = {ENC1_B, ENC2_B, ENC3_B, ENC4_B, ENC5_B};

// Motor state variables
volatile bool motorStates[5] = {false, false, false, false, false}; // On/off state for each motor
volatile int motorDirections[5] = {0, 0, 0, 0, 0};                 // Direction for each motor (0=CW, 1=CCW)
volatile int activeMotors = 0;                                     // Count of active motors
volatile int commutationSteps[5] = {0, 0, 0, 0, 0};               // Track each motor's commutation step

// Claw state variable
volatile bool clawClosed = false;       // Claw state: false = open, true = closed

// Encoder variables
#define PPR 1000 // Pulses per revolution (adjust for your encoder)
const float COUNTS_PER_REV = PPR * 4.0; // 4x decoding for quadrature
const float DEG_PER_COUNT = 360.0 / COUNTS_PER_REV; // Degrees per count
volatile long encoderCounts[5] = {0, 0, 0, 0, 0}; // Pulse counts for each motor
float motorAngles[5] = {0.0, 0.0, 0.0, 0.0, 0.0}; // Angles in degrees

// Command structure
typedef struct {
  int motorNum;    // 1-5 for specific motor, 0 for none
  bool turnOn;     // true = ON, false = OFF
  int direction;   // 0 = CW, 1 = CCW, -1 = no change
} MotorCommand_t;

// FreeRTOS handles
TaskHandle_t motorTaskHandle = NULL;
TaskHandle_t encoderTaskHandle = NULL;
QueueHandle_t commandQueue;
SemaphoreHandle_t motorMutex;
SemaphoreHandle_t encoderMutex;
SemaphoreHandle_t bleMutex;

// Serial command handling
String inputString = "";
bool stringComplete = false;

// Function prototypes
void motorControlTask(void* pvParameters);
void encoderTask(void* pvParameters);
void commTask(void* pvParameters);
void motorControl(int motorIdx, int dir);
void controlClaw(bool close);
void processCommand(String command);
void updateBLE(String message);

// Individual interrupt handlers for each encoder
void IRAM_ATTR handleEncoder1Change() {
  int a = digitalRead(ENC_A_PINS[0]);
  int b = digitalRead(ENC_B_PINS[0]);
  
  // Determine direction based on the state of both pins
  if (a == b) {
    encoderCounts[0]++; // CW
  } else {
    encoderCounts[0]--; // CCW
  }
}

void IRAM_ATTR handleEncoder2Change() {
  int a = digitalRead(ENC_A_PINS[1]);
  int b = digitalRead(ENC_B_PINS[1]);
  
  if (a == b) {
    encoderCounts[1]++; // CW
  } else {
    encoderCounts[1]--; // CCW
  }
}

void IRAM_ATTR handleEncoder3Change() {
  int a = digitalRead(ENC_A_PINS[2]);
  int b = digitalRead(ENC_B_PINS[2]);
  
  if (a == b) {
    encoderCounts[2]++; // CW
  } else {
    encoderCounts[2]--; // CCW
  }
}

void IRAM_ATTR handleEncoder4Change() {
  int a = digitalRead(ENC_A_PINS[3]);
  int b = digitalRead(ENC_B_PINS[3]);
  
  if (a == b) {
    encoderCounts[3]++; // CW
  } else {
    encoderCounts[3]--; // CCW
  }
}

void IRAM_ATTR handleEncoder5Change() {
  int a = digitalRead(ENC_A_PINS[4]);
  int b = digitalRead(ENC_B_PINS[4]);
  
  if (a == b) {
    encoderCounts[4]++; // CW
  } else {
    encoderCounts[4]--; // CCW
  }
}

// Setup encoder interrupts
void setupEncoderInterrupts() {
  // Setup each encoder's pins and interrupts individually
  pinMode(ENC_A_PINS[0], INPUT_PULLUP);
  pinMode(ENC_B_PINS[0], INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_A_PINS[0]), handleEncoder1Change, CHANGE);
  
  pinMode(ENC_A_PINS[1], INPUT_PULLUP);
  pinMode(ENC_B_PINS[1], INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_A_PINS[1]), handleEncoder2Change, CHANGE);
  
  pinMode(ENC_A_PINS[2], INPUT_PULLUP);
  pinMode(ENC_B_PINS[2], INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_A_PINS[2]), handleEncoder3Change, CHANGE);
  
  pinMode(ENC_A_PINS[3], INPUT_PULLUP);
  pinMode(ENC_B_PINS[3], INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_A_PINS[3]), handleEncoder4Change, CHANGE);
  
  pinMode(ENC_A_PINS[4], INPUT_PULLUP);
  pinMode(ENC_B_PINS[4], INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_A_PINS[4]), handleEncoder5Change, CHANGE);
}

void setup() {
  // Initialize USB Serial for debugging
  Serial.begin(115200);
  delay(1000); // Wait for Serial Monitor
  Serial.println("Booting ESP32-S3...");

  // Initialize BLE
  if (!BLE.begin()) {
    Serial.println("Starting BLE failed!");
    while (1);
  }
  
  BLE.setLocalName("ESP32_MOTORS");
  BLE.setAdvertisedService(uartService);
  uartService.addCharacteristic(rxCharacteristic);
  uartService.addCharacteristic(txCharacteristic);
  BLE.addService(uartService);
  BLE.advertise();
  Serial.println("BLE Started! Connect with 'ESP32_MOTORS'");

  // Create FreeRTOS structures
  commandQueue = xQueueCreate(20, sizeof(MotorCommand_t));
  motorMutex = xSemaphoreCreateMutex();
  encoderMutex = xSemaphoreCreateMutex();
  bleMutex = xSemaphoreCreateMutex();

  // Configure driver pins
  pinMode(HIN1, OUTPUT); pinMode(HIN2, OUTPUT); pinMode(HIN3, OUTPUT);
  pinMode(LIN1, OUTPUT); pinMode(LIN2, OUTPUT); pinMode(LIN3, OUTPUT);
  digitalWrite(HIN1, LOW); digitalWrite(HIN2, LOW); digitalWrite(HIN3, LOW);
  digitalWrite(LIN1, LOW); digitalWrite(LIN2, LOW); digitalWrite(LIN3, LOW);
  Serial.println("Gate driver pins initialized LOW");

  // Configure relay pins (active LOW)
  for (int i = 0; i < 5; i++) {
    pinMode(RELAY_PINS[i], OUTPUT);
    digitalWrite(RELAY_PINS[i], HIGH); // Ensure relays OFF
    Serial.printf("Relay %d (Pin %d) initialized HIGH (OFF)\n", i + 1, RELAY_PINS[i]);
  }

  // Configure claw motor control pins
  pinMode(CLAW_IN1, OUTPUT);
  pinMode(CLAW_IN2, OUTPUT);
  digitalWrite(CLAW_IN1, LOW);
  digitalWrite(CLAW_IN2, LOW);

  // Setup encoder interrupts
  setupEncoderInterrupts();
  Serial.println("Encoder interrupts initialized");

  // Create motor control task on core 0
  xTaskCreatePinnedToCore(
    motorControlTask,
    "MotorTask",
    8192,
    NULL,
    2, // Higher priority for motor control
    &motorTaskHandle,
    0  // Run on core 0
  );

  // Create encoder processing task on core 1
  xTaskCreatePinnedToCore(
    encoderTask,
    "EncoderTask",
    4096,
    NULL,
    1,
    &encoderTaskHandle,
    1  // Run on core 1
  );

  // Create communication task on core 1
  xTaskCreatePinnedToCore(
    commTask,
    "CommTask",
    8192,
    NULL,
    1,
    NULL,
    1  // Run on core 1
  );

  Serial.println("Motor Control System Ready");
  txCharacteristic.writeValue("Motor Control System Ready");
}

void loop() {
  // Read serial commands
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    if (inChar != '\n' && inChar != '\r') {
      inputString += inChar;
    }
    if (inChar == '\n') {
      stringComplete = true;
    }
  }

  if (stringComplete) {
    processCommand(inputString);
    inputString = "";
    stringComplete = false;
  }
  
  // Handle BLE in the loop to avoid processing issues
  BLEDevice central = BLE.central();
  
  if (central) {
    static bool wasConnected = false;
    if (!wasConnected) {
      Serial.print("Connected to: ");
      Serial.println(central.address());
      updateBLE("Connected");
      wasConnected = true;
    }
    
    // Check for received BLE data
    if (rxCharacteristic.written()) {
      String command = rxCharacteristic.value();
      Serial.print("BLE command: ");
      Serial.println(command);
      processCommand(command);
    }
  } else {
    static bool wasConnected = false;
    if (wasConnected) {
      Serial.println("Disconnected");
      wasConnected = false;
    }
  }
  
  delay(10); // Small delay to prevent loop from consuming too much CPU
}

// Process incoming commands
void processCommand(String command) {
  command.trim();
  command.toUpperCase();
  Serial.print("Command received: ");
  Serial.println(command);

  MotorCommand_t cmd;
  cmd.turnOn = false;
  cmd.direction = -1;
  cmd.motorNum = 0;

  // Check for claw commands
  if (command == "C1") {
    controlClaw(true);
    updateBLE("Claw closing");
    return;
  }
  if (command == "C0") {
    controlClaw(false);
    updateBLE("Claw opening");
    return;
  }

  // Test relays command
  if (command == "TESTRELAYS") {
    Serial.println("Testing relays...");
    updateBLE("Testing relays...");
    for (int i = 0; i < 5; i++) {
      digitalWrite(RELAY_PINS[i], LOW);  // ON
      delay(1000);
      digitalWrite(RELAY_PINS[i], HIGH); // OFF
      delay(500);
    }
    updateBLE("Relay test complete");
    return;
  }

  // Individual motor commands
  for (int i = 1; i <= 5; i++) {
    String motorNum = String(i);
    
    if (command == "M" + motorNum + "ON") {
      cmd.motorNum = i;
      cmd.turnOn = true;
      xQueueSend(commandQueue, &cmd, portMAX_DELAY);
      updateBLE("Motor " + motorNum + " turning ON");
      return;
    }
    if (command == "M" + motorNum + "OFF") {
      cmd.motorNum = i;
      cmd.turnOn = false;
      xQueueSend(commandQueue, &cmd, portMAX_DELAY);
      updateBLE("Motor " + motorNum + " turning OFF");
      return;
    }
    if (command == "M" + motorNum + "0" || command == "M" + motorNum + "CW") {
      cmd.motorNum = i;
      cmd.direction = 0;
      xQueueSend(commandQueue, &cmd, portMAX_DELAY);
      updateBLE("Motor " + motorNum + " set to Clockwise");
      return;
    }
    if (command == "M" + motorNum + "1" || command == "M" + motorNum + "CCW") {
      cmd.motorNum = i;
      cmd.direction = 1;
      xQueueSend(commandQueue, &cmd, portMAX_DELAY);
      updateBLE("Motor " + motorNum + " set to Counter-Clockwise");
      return;
    }
  }

  if (command == "ALLOFF") {
    for (int i = 1; i <= 5; i++) {
      cmd.motorNum = i;
      cmd.turnOn = false;
      xQueueSend(commandQueue, &cmd, 0);
    }
    updateBLE("All motors OFF");
    return;
  }

  if (command == "ALLCW") {
    for (int i = 1; i <= 5; i++) {
      cmd.motorNum = i;
      cmd.direction = 0;
      xQueueSend(commandQueue, &cmd, 0);
    }
    updateBLE("All motors set to CW");
    return;
  }

  if (command == "ALLCCW") {
    for (int i = 1; i <= 5; i++) {
      cmd.motorNum = i;
      cmd.direction = 1;
      xQueueSend(commandQueue, &cmd, 0);
    }
    updateBLE("All motors set to CCW");
    return;
  }

  if (command == "RESET") {
    ESP.restart();
    return;
  }

  updateBLE("Unknown command");
}

// Task to handle motor control
void motorControlTask(void* pvParameters) {
  MotorCommand_t cmd;
  const TickType_t xDelay = pdMS_TO_TICKS(5);
  
  // Motor timing parameters
  const int motorSpeed = 5; // Commutation delay
  
  while (1) {
    // Check for new commands (non-blocking)
    if (xQueueReceive(commandQueue, &cmd, 0) == pdTRUE) {
      int motorIndex = cmd.motorNum - 1;
      
      // Only process valid motor indices
      if (motorIndex >= 0 && motorIndex < 5) {
        xSemaphoreTake(motorMutex, portMAX_DELAY);
        
        // Update direction if needed
        if (cmd.direction >= 0) {
          motorDirections[motorIndex] = cmd.direction;
          Serial.printf("Motor %d direction set to %s\n", 
                     motorIndex + 1, motorDirections[motorIndex] == 0 ? "CW" : "CCW");
        }
        
        // Update motor on/off state
        bool wasRunning = motorStates[motorIndex];
        motorStates[motorIndex] = cmd.turnOn;
        
        // Update relay state
        digitalWrite(RELAY_PINS[motorIndex], motorStates[motorIndex] ? LOW : HIGH);
        
        // Update active motors count
        if (motorStates[motorIndex] && !wasRunning) {
          activeMotors++;
        } else if (!motorStates[motorIndex] && wasRunning) {
          activeMotors--;
        }
        
        xSemaphoreGive(motorMutex);
      }
    }
    
    // Process all active motors
    xSemaphoreTake(motorMutex, portMAX_DELAY);
    for (int i = 0; i < 5; i++) {
      if (motorStates[i]) {
        // Run one commutation step for this motor
        motorControl(i, motorDirections[i]);
      }
    }
    xSemaphoreGive(motorMutex);
    
    // Short delay between commutation cycles
    vTaskDelay(xDelay);
  }
}

// Motor driving sequence for a specific motor
void motorControl(int motorIdx, int dir) {
  // Get current step for this motor
  int step = commutationSteps[motorIdx];
  
  // All pins LOW by default
  bool h1 = LOW, h2 = LOW, h3 = LOW, l1 = LOW, l2 = LOW, l3 = LOW;
  
  // Set pins according to commutation step and direction
  if (dir == 0) { // Clockwise
    switch (step) {
      case 0: l1 = HIGH; break;
      case 1: h2 = HIGH; break;
      case 2: l3 = HIGH; break;
      case 3: h1 = HIGH; break;
      case 4: l2 = HIGH; break;
      case 5: h3 = HIGH; break;
    }
  } else { // Counter-clockwise
    switch (step) {
      case 0: l1 = HIGH; break;
      case 1: h3 = HIGH; break;
      case 2: l2 = HIGH; break;
      case 3: h1 = HIGH; break;
      case 4: l3 = HIGH; break;
      case 5: h2 = HIGH; break;
    }
  }
  
  // Only apply signals when this is active motor
  if (motorStates[motorIdx]) {
    digitalWrite(HIN1, h1);
    digitalWrite(HIN2, h2);
    digitalWrite(HIN3, h3);
    digitalWrite(LIN1, l1);
    digitalWrite(LIN2, l2);
    digitalWrite(LIN3, l3);
  }
  
  // Increment step for next commutation
  commutationSteps[motorIdx] = (commutationSteps[motorIdx] + 1) % 6;
}

// Task to process encoder data
void encoderTask(void* pvParameters) {
  TickType_t lastWakeTime = xTaskGetTickCount();
  
  while (1) {
    // Update motor angles from encoder counts
    xSemaphoreTake(encoderMutex, portMAX_DELAY);
    for (int i = 0; i < 5; i++) {
      motorAngles[i] = encoderCounts[i] * DEG_PER_COUNT;
    }
    xSemaphoreGive(encoderMutex);
    
    // Send encoder data only for active motors to reduce BLE traffic
    String angleReport = "Angles:";
    bool hasActive = false;
    
    for (int i = 0; i < 5; i++) {
      if (motorStates[i]) {
        angleReport += " M" + String(i + 1) + ":" + String(motorAngles[i], 1) + "°";
        hasActive = true;
      }
    }
    
    if (hasActive) {
      updateBLE(angleReport);
    }
    
    // Use vTaskDelayUntil to ensure consistent timing
    vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(500));
  }
}

// Task to handle communications (Serial and BLE status updates)
void commTask(void* pvParameters) {
  TickType_t lastStatusTime = xTaskGetTickCount();
  
  while (1) {
    // Report motor status periodically
    if (xTaskGetTickCount() - lastStatusTime >= pdMS_TO_TICKS(2000)) {
      String status = "Status:";
      bool hasActive = false;
      
      xSemaphoreTake(motorMutex, portMAX_DELAY);
      for (int i = 0; i < 5; i++) {
        if (motorStates[i]) {
          status += " M" + String(i + 1) + ":" + (motorDirections[i] == 0 ? "CW" : "CCW");
          hasActive = true;
        }
      }
      xSemaphoreGive(motorMutex);
      
      if (hasActive) {
        Serial.println(status);
        updateBLE(status);
      }
      
      lastStatusTime = xTaskGetTickCount();
    }
    
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// Helper function to send BLE updates
void updateBLE(String message) {
  xSemaphoreTake(bleMutex, portMAX_DELAY);
  
  // Only send if a device is connected and subscribed
  if (BLE.connected() && txCharacteristic.subscribed()) {
    txCharacteristic.writeValue(message);
  }
  
  xSemaphoreGive(bleMutex);
  
  // Also print to serial for debugging
  Serial.println(message);
}

// Claw control function
void controlClaw(bool close) {
  if (close) {
    digitalWrite(CLAW_IN1, HIGH);
    digitalWrite(CLAW_IN2, LOW);
  } else {
    digitalWrite(CLAW_IN1, LOW);
    digitalWrite(CLAW_IN2, HIGH);
  }
  
  delay(500);  // Run for 500ms then stop
  
  digitalWrite(CLAW_IN1, LOW);
  digitalWrite(CLAW_IN2, LOW);
  
  clawClosed = close;
  Serial.printf("Claw %s\n", close ? "closed" : "opened");
}
